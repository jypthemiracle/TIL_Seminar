# DDD 도메인 주도 설계   
> Domain-Driven-Design   

소프트웨어의 복잡성을 낮추는 기술 중 하나     
소프트웨어가 복잡한 이유는 **도메인이 복잡하기 때문이다.**        
       
우리는 도메인을 올바르게 표현하고 관리할 방법을 알아야하는데        
그렇지 않고 '이 기술을 사용하면 소프트웨어의 복잡도를 낮출 수 있는데'라면서 착각을 하는데 그렇지 않다.        
         
예를 들면 머신러닝을 활용했을 때 여러 패턴들을 사용해서 복잡도를 낮춘다 하더라도 이는 한계가 있다.           
왜? 머신 러닝 자체가 복잡하고 내부 로직을 개선해야지만 그 복잡도가 낮아지니까.(이를 위해서 수학 필요)               
      
다른 예로 회계 프로그래밍을 작성한다 치는데 복잡성이 높다. 왜? 회계가 복잡하니까.     
여기서 도메인 주도 설계는 **기존 회계 도메인의 복잡성을 개발자가 해당 전문가가 되듯이 복잡성을 낮추는 설꼐**라고 생각하면 된다.     
즉, 기존 회계 시스템을 유지하되 복잡도를 낮추는 코딩을 하는 것이 아니라           
기존의 회계 시스템 자체를 '어떻게 하면 조금 더 편리하게 바꾸지'하면서 개발하는 것이다.         

**이렇듯 프로그래밍 스킬이 아니라 도메인 전문가와 함께 해당 도메인의 복잡성을 낮추는 알고리즘이나 로직을 개발하는 것이다.**        
그리고 이 과정에서 도메인과 모델에서 공용(표준)으로 사용될 **유비쿼터스 랭귀지**도 만들고 이에 해당하는 객체를 만든다.      
예를 들면 `스위치 - 전원 스위치/닌텐도 스위치 등..`와 같이 이름이 같지만 다른 개념들을          
하나의 스위치 클래스로 만드는 것이 아니라 각각의 `class 게임_스위치`, `class 전원_스위치` 같이 만드는 것이다.         
그래서 이런 컨텍스트들을 따로 따로 넣고 바운드 컨텍스트를 만들고 조직마다 다를거고 이런 것을 도메인 주도 설계라고 한다.       

총 정리 :    
도메인이 복잡하면 코드가 복잡해진다.           
이 때문에 기존 도메인을 그대로 다양한 디자인 패턴을 사용하더라도 한계가 있다.     
그렇기에 도메인의 복잡성을 도메인 전문가와 협업하여 낮추도록 개발하는 것이고 
이 과정에서 유비쿼터스 랭귀지를 만들고 각각의 바운드 컨텍스트에 알맞은 컨텍스트를 넣어준다. (게임-스위치, 건설-스위치)     
즉, 도메인의 복잡성을 낮추기 위해 개발하는 모든 과정을 도메인 주도 설계라 한다.   

# 목차    

1. Domain, DDD(Domain Driven Design)란?    
2. 왜 도메인 주도 설계인가?    
3. DDD의 전략적, 전술적 패턴   

# DDD 도메인 주도 설계   
**도메인 :**    
* 사용자가 사용하는 것, 소프트웨어로 해결하고자 하는 문제      
* 비즈니스 영역     
* 여기서는 우리가 아는 URL 도메인을 이야기하지는 않는다.    

**도메인 주도 설계**    
* 도메인을 중심으로 하는 개발 방식
  * **도메인에 관련된 문제를 해결하는 것**       
* 복잡한 도메인을 해결하는 것을 높은 우선순위로 생각해 서비스를 만들어 나가는 방법    
  * 도메인의 복잡성을 조금 더 쉽게 다룰 수 있게 도와주는 도구    

[사진]  
[사진]    

**유비쿼터스 랭귀지(보편언어)**    
* 도메인에 대한 어휘를 이해관계자(도메인 전문가, 개발자, 분석가..)들이 공통적으로 의미를 이해할 수 있도록 정의하는 것   

**모델 주도 설계**     
* 분석과 설계를 나누지 않으며 분석/설계/구현의 모든 단계를 관통하는 하나의 모델을 유지   
* 모델링 통해 가져올 수 있는 통찰을 코드에도 적용   
* 모델 == 코드    
  * 모델이 바뀐다면 코드가 바뀌고 코드가 바뀌면 모델이 바뀌어야 한다.   
     
**도메인 모델**    
* 도메인에 대한 구체적인 설계, 도메인을 개념적으로 표현한 것        
* 개념들의 관계를 표현한 모델            
* 문제 영역을 시각화         

**도메인 주도 설계**
* 복잡한 소프트웨어는 기술 자체의 복잡성 보다는 도메인 자체의 복잡성에 기인    
  * 도메인을 가장 잘 아는 사람(도메인 전문가)과 어떻게 협업할 것인지가 가장 중요   
  * 유비쿼터스 랭귀지, 모델 주도 디자인   

## 등장 배경    
* 데이터에 종속적인 애플리케이션   
* 모델링과 개발과의 불일치   

### 데이터 중심적인 접근법   
* 기존 개발은 DB 테이블 중심
* 빈약한 도메인 모델   

### 빈약한 도메인 모델
* Getter 와 Setter만으로 구성 된 모델
* 데이터만 가지는 데이터홀더 개념   
* Big Service Layer
   
-> 모델과 구현(코드)의 불일치가 발생, 소통의 어려움   

# DDD OverView   
  
![DDD-Pattern-Language-Overview-sml](https://user-images.githubusercontent.com/50267433/99480455-75535f80-299b-11eb-9cbd-cd658804eee5.png)       
![DDD-Pattern-Language-Overview-sml_divide](https://user-images.githubusercontent.com/50267433/99480749-1215fd00-299c-11eb-97e4-bfdc7c45b6c9.png)    
   
   
* 전략적 설계 
  * 개념 설계  
* 전술적 설계   
  * 구체적 설계   
  
## 전략적 설계  
* 복잡한 도메인의 맥락(Context) 경계를 명확히 정의하는 과정    
* Bounded Context 안의 도메인 모델에서 보편 언어를 개발하는 방법  
  * 도메인에 집중하면 도메인이 설명하는 범위와 도메인 간의 경계들이 명확하게 드러나는데, 이를 Bounded context라고 합니다.    
* 도메인에서 서브 도메인으로 복잡성 분리   
  * 핵심, 지원 도메인 파악 - 관점 파악 -> AOP의 근간?    
* 컨텍스트 맵핑 기술을 활용해 여러 개의 Bounded Context 통합   
* 이벤트 스토밍 기법을 활용해 Bounded Context 식별   
    
### 진흙 덩어리 문제   
   
[사진]    
   
## 전술적 설계    
* 전략적 설계에서 더 상세한 부분(바운디드 컨텍스트 내부)모델링   
* Model Driven Design - MDD   
* 빌딩 블록(패턴)을 사용해 모델링 - Aggregate 패턴    
* 계층형 아키텍처를 통한 도메인 모델 분리   
* 도메인 이벤트를 통해 도메인을 보다 명확히 모델링  
 
### 전술적 설계 Building Block   
[사진]  
[사진]   
[사진]
 
# DDD 결론  
* 흔히 DDD를 떠올리면 DDD의 전술적 설계에 대한 개념을 많이들 떠올립니다.(Entity, ValueObject, Aggregate)     
* 물론 DDD의 전술적 설계만 했을 시에도 장점 존재 - DDD Lite        
* 하지만 DDD는 이러한 패턴보다는 협업을 통한 문제 해결이 더 강조        
  

# 개인적인 생각으로는 
같은 뜻을 가진 여러개의 개념을 한개의 클래스로만 표현하지 않고   
각각의 클래스로 만들어 활용하는 것이라 생각한다.  
 
 
# 참고 
블로그   
https://nesoy.github.io/articles/2018-07/DDD-Bounded-Context  - boundedContext   


