# 들어가면서 Cache

# 메모리 계층 구조 (Memory hierarchy)

![65787465726e616c2f63732e757765632e6564752f6d656d6f72795f6869657261726368792e706e67](https://user-images.githubusercontent.com/50267433/98894992-5f502580-24e9-11eb-84e3-74bf4b1d9f8a.png)  
  
* **데이터를 저장하는 공간의 속도와 용량은 반비례 관계**    
  * 속도가 빠른 메모리일수록 용량이 적다.   
  * 용량이 큰 저장장치는 속도가 느리다.   
  * 둘 다 잡기에는 비용이 너무 많이 든다.   
  * 그래서 데이터 저장 공간은 **속도와 용량에 따라 특성에 맞게 역할을 나누어서 사용한다.**      
* 데이터 저장 공간을 속도-용량 순서대로 쌓으면 마치 피라미드와 같은 현상이 나타난다. 

# 파레토 법칙
![Long_tail](https://user-images.githubusercontent.com/50267433/98895986-5b250780-24eb-11eb-80a3-79805862e1c8.jpg)    
    
* 이탈리아의 경제학자 빌프레도 파레토가 발견한 현상    
* 원인 중 상위 20%가 전체 결과의 80%를 만든다는 법칙     
* 2 대 8 법칙이라고도 한다.
* 여러 곳에서 관찰할 수 있다.   
  * 인구의 20%가 전체 부의 80%를 가지고 있다.   
  * 잘 팔리는 제품 20%가 매출의 80%를 차지한다.     
  * 많이 쓰이는 단어 20%가 언어 사용빈도의 80%를 차지한다.   

```
그렇다면 전체 결과의 80%를 저장하는 20%만 빠른 저장장치에 넣으면 되겠네!!!  
```

# 데이터 지역성의 원리    
* 자주 쓰이는 데이터는 시간적 혹은 공간적으로 한 곳에 몰려 있을 가능성이 높다.   
  * **시간 지역성 :**      
  예를 들어 `for문`에서 조건변수`(int i=0;)`를 선언했을 때.      
  해당 변수는 `for문`이 끝나기 전까지 계속 쓰일 확률이 높은 것   
  * **공간 지역성 :**             
  예를 들어 `for문`에서 어떤 배열에 접근했을 때.          
  해당 배열의 위치한 메모리 공간의 내용은 `for문`이 끝나기 전까지 계속 쓰일 확률이 높은것            
  * **순차 지역성 :**    
  `for문`에서 `array[0]`, `array[1]`, `array[2]` 와 같이 배열에 접근할 때   
  다음번에는 `array[3]`에 접근할 확률이 높은 것을 따로 분류하여 순차 지역성이라고 부릅니다.       
     
# 캐시   
**캐시 :** 나중에 필요할 수도 있는 무언가를 저장하였다가 신속하게 회수할 수 있는 보관 장소로, 어떤 식으로든 보호되거나 숨겨진다.     
     
## 캐시의 작동 방식          
* 원본 데이터와는 별개로 자주 쓰이는 데이터들을 복사해둘 **캐시 공간을 마련**한다.           
캐시 공간은 상수 시간등 **낮은 시간 복잡도로 접근 가능한 곳**을 주로 사용한다.      

* 데이터를 달라는 요청이 들어오면 원본 데이터가 담긴 곳에 접근하기 전에 먼저 **캐시 내부부터 찾는다.**       

* 캐시에 원하는 데이터가 없거나(Cache Miss)   
너무 오래되어 최신성을 잃었으면(Expiration)   
그때서야 원본 데이터가 있는 곳에 접근하여 데이터를 가져온다.   
이때 데이터를 가져오면서 캐시에도 해당 데이터를 복사하거나 갱신한다.   

* 캐시에 원하는 데이터가 있으면 원본 데이터가 있는 공간에 접근하지 않고 캐시에서 바로 해당 데이터를 제공한다. (Cache hit)   
   
* 캐시 공간은 작으므로. 공간이 모자르게 되면 안 쓰는 데이터부터 삭제하여 공간을 확보한다.(Eviction) - LRU 알고리즘   

```
여기서 주의점은 
* 최신성을 잃었으면(Expiration)
* 안 쓰는 데이터부터 삭제(Eviction)
는 다른 개념이다.   

Expiration 는 얻어오는 동작시 공간이 넉넉한데도 최신성을 잃으면 데이터베이스에서 얻는다는 말     
Eviction 는 저장시 공간이 넉넉하지 않으면 LRU를 기반으로 안쓰는 데이터를 삭제하겠다는말이다.     
   
공간이 빽빽하다면 최신성을 지우는 것은 아니고 LRU 기반으로 기반으로 안쓰는 데이터부터 삭제한다.   
```

## CPU의 캐시 메모리   
* 현대의 CPU는 1초에 최고 수십억 번 작동 가능하다.    
  * 아무리 빠른 주기억장치라도 CPU를 따라가기 어려움   
  * 그래서 SRAM이라는 특수한 메모리를 CPU에 넣어 캐시 메모리로 사용   
* 최근 출시된 AMD의 3세대 RYZEN CPU는 L3 캐시 메모리의 용량을 기존의 2배로 늘려 게이밍 성능을 인텔 제품과 동등한 수준으로 끌어올렸다.     
  * 이름 자체가 `게임캐시(GAME CACHE)` 
  * 캐시가 효율 향상에 중요함을 보여주는 한 사례   
  
## 하드디스크 / 데이터베이스  
* 하드디스크는 주기억장치에 비해 `10만배 이상 느린 장치`       
* 처리 효율을 올리려면 **자주 쓰이는 데이터를 캐싱**해두는 것이 좋다.   
* 데이터베이스 또한 쿼리를 실행하여 하드디스크에서 데이터를 읽고 쓰는 것은 시간이 오래 걸리는 작업    
* 대개 데이터베이스는 쓰기보다는 읽기가 많으므로 **자주 요청받는 쿼리의 결과를 캐싱해두면 효율이 좋아진다.**   
* 따라서 데이터베이스 자체에서 별도의 캐ㅑ시를 운영한다.   
  * JPA의 영속성 컨텍스트도 실은 캐시의 일종이다.   

```
필자가 덧붙여서 말하자면   
캐시를 이용한 방식을 사용하더라도 하드디스크를 사용하는 것이므로 더 개선해야할 사항이 많다.   
그래서 NoSQL 형태의 인메모리 데이터베이스를 사용하는 경우가 많다.   
```       
   
## CDN   
* YouTube의 메인 서버는 미국에 있다.        
* 한국과 미국을 잇는 국제 인터넷 회선은 비싸고 용량을 늘리기도 어렵다.       
* 구글은 각 통신사마다 Google Global Cache를 두어      
인기 있는 YouTube 동영상은 미국 서버까지 접속할 필요 없이 국내 서버에서 처리하도록 하였다.       
* 비싼 국제 회선 비용이 절감되고, 버퍼링이 줄어 고화질 서비스의 이용 경험이 개선되었다.   
* 이처럼 세계 각지에 캐시 서버를 두어 전송속도를 높이고 부하를 분산하는 시스템이 바로 CDN이다.   
      
**CDN - Content Delivery Network**
```
사용자와 가까운 곳에 위치한 Cache Server에 해당 Content를 저장(캐싱)하고 Content 요청시에 Cache Server가 응답을 주는 기술이다.
     
Edge Computer 와의 차이는?       
CDN 은 단순 컨텐츠 캐싱이 목적으로 가까운 캐싱서버에 콘텐츠를 저장하고 읽는 용도이지만      
Edge Computer 는 AWS의 서비스를 한국에서 사용할 수 있듯이 저장하고 읽는 용도를 넘어 CPU 처리를 보다 가까운 지역에서 하게끔 도와주는 것이다.     
```   
   
## 웹 캐시  
* 네트워크를 통해 데이터를 가져오는 것은 하드디스크보다도 느릴 때가 많다. (네트워크 속도도 영향을 받으므로)

* **웹 브라우저 :**        
웹 페이지에 접속할 때 HTML, CSS, JAVASCRIPT, 이미지등을         
하드디스크나 메모리에 캐싱해뒀다가 다음 번에 다시 접속할 때 이를 재활용한다.(브라우저 캐시)       
* **웹 서버 :**         
상당수의 경우 동적 웹 페이지라 할지라도 매번 내용이 바뀌지 않는 경우가 더 많으므로      
서버에서 생성한 HTML을 캐싱해 뒀다가 다음 번 요청에 이를 재활용한다.(응답 캐시)    

* 이와 유사하게, 클라이언트에서 자주 요청받는 내용은 웹 서버로 전달되지 않고       
웹 서버 앞단의 프록시 서버에서 캐싱해둔 데이터를 바로 제공하기도 한다.(프록시 캐시)   

### 브라우저 캐시    
* 웹 서버에서 클라이언트에 보내는 HTTP 헤더에 캐시 지시자를 삽입하면,              
클라이언트 웹 브라우저에서는 해당 지시자에 명시된 캐시 정책에 따라 캐싱을 실시한다.           
  * 이 파일은 캐시를 언제까지해라   
  * 이 파일은 캐시를 하지 말아라 지시해줍니다.   
    
* 캐시의 유효시간(max-age)이 지나도 캐시된 데이터가 바뀌지 않은 경우를 확인하기 위해 ETag라는 유효성 검사 토큰을 사용한다.     
  * 유효시간과는 별도로 데이터가 변했는지 확인하기 위한 태그, 즉 유효시간이 지나도 ETag 유효성을 검사합니다.    
  * 캐싱된 것을 무효화하고 받아올 필요가 있는지 검증하는 것   
      
* 때로는 캐시 유효 시간을 최대한 길게 잡으면서도 정적 파일의 업데이트를 신속히 적용하기 위해       
정적 파일의 이름 뒤에 별도의 토큰이나 버전 번호를 붙여야 하는 경우도 있다.      
  * 캐싱 기간을 길게하고 캐싱된 파일을 수정했는데 수정된 파일을 불러오지 않고 옛날 버전을 가져오는 문제가 있다.   
  * 이를 해결하기 위해 버전 번호를 붙여놓고 정렬하는 방식으로 사용한다.  
  * http header 에다가 붙이는 것은 안된다. -> 파일 이름이 다르면 무효화가 되니까. -> 파일 그대로 저장하고 이름을 바꾼다.   
  
* 캐시 정책은 해당 웹 페이지의 전반적인 상황에 따라 각 파일마다 다르게 적용되어야 한다.       
**적어도 정적 파일과 동적인 부분의 브라우저 캐싱 정책은 달라야한다.**          
비공개 정보가 담긴 페이지는 보안상 아에 캐싱을 막아야 할 수 있다.      
  * 이 부분은 발표자님도 아직 모르시던때라서 추가로 공부해야겠다.   

## Redis    
* 메모리 기반의 오픈소스 NoSQL DBMS의 일종으로, 웹 서비스에서 캐싱을 위해 많이들 쓴다.    
* Redis라는 이름은 Remote Dictionary Server 의 약자이다.   
* 여기서 Dictionary 는 JAVA의 HashMap<Key, value> 를 생각하면 된다.   
* 기본적으로 모든 데이터를 메모리에 저장하여 처리하므로 속도가 빠르다.   
* 서버 재부팅 때 메모리의 데이터가 휘발되지 않게끔 데이터를 하드디스크에 기록할 수 있다.   
* DBMS의 일종이므로, 명시적으로 삭제하지 않는 한 메모리에서 데이터를 삭제하지 않는다.    
* 자체적으로 여러 가지 자료형을 지원한다. 

## EHcache    
* JAVA의 표준 캐싱 API 명세인 JSR-107을 따르는 오픈소스 캐시 구현체    
* Spring 프레임워크나 Hibernate ORM 등에서 바로 사용 가능   
* JAVA 진영에서 가장 널리 쓰인다고 함   
* 캐시 저장공간을 속도에 따라 여러 등급(Tier)으로 나누어 메모리 계층 구조를 적용 가능    
* 메모리에 캐시된 내용을 하드디스크에 기록 가능   
* 대규모 서비스에서 캐시 서버 여럭을 클러스터로 묶을 수 있는 기능을 제공   





